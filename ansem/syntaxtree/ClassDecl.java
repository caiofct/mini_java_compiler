//
// Generated by JTB 1.3.2
//

package ansem.syntaxtree;

import gci.tree.IRType;
import java.util.Hashtable;
import java.util.Vector;

/**
 * Grammar production:
 * <PRE>
 * f0 -> &lt;CLASS&gt; &lt;ID&gt; &lt;LCHAVE&gt; ( VarDecl() )* ( MethodDecl() )* &lt;RCHAVE&gt;
 *       | &lt;CLASS&gt; &lt;ID&gt; &lt;EXTENDS&gt; &lt;ID&gt; &lt;LCHAVE&gt; ( VarDecl() )* ( MethodDecl() )* &lt;RCHAVE&gt;
 * </PRE>
 */
public class ClassDecl implements Node {
   public NodeChoice f0;
   public String name; //nome da classe
   public String parent; //pai da classe
   public Hashtable<String, String> hashVariables; //variáveis da classe
   private Hashtable<String, Vector<MethodDecl> > hashMethods; //métodos da classe
   
   public ClassDecl(NodeChoice n0) {
      f0 = n0;
      //variáveis da classe
      hashVariables = new Hashtable<String, String>();
      //contém os métodos da classe, cada classe pode ter mais de um método com o mesmo nome(sobrecarga)
      hashMethods = new Hashtable<String, Vector<MethodDecl> >();

   }

   /**
    * Retorna o tipo da variavel
    * @param variavel
    * @return
    */
   public String getVariableType(String variavel)
   {
       return this.hashVariables.get(variavel);
   }

   public Hashtable<String, Vector<MethodDecl>> getMethods()
   {
       return hashMethods;
   }

   public int getTotalVariaveis()
   {
       return hashVariables.size();
   }
   /**
    * Adicionar uma variável em uma classe ou em um método
    *
    * @param id O nome da variável
    * @param type O tipo da variável
    */
   public boolean addVar(String id, String type)
   {
      if(hashVariables.containsKey(id)) return false;

      hashVariables.put(id, type);
      return true;
   }

   /**
    * Adicionar método em uma determinada classe
    *
    * @param id Nome do método
    * @param method Método a ser adicionado
    */
   public void addMethod(String id, MethodDecl method) throws SemanticException
   {
      if(hashMethods.containsKey(id))
      {
          NodeToken nt;

          for(int i = 0; i < hashMethods.get(id).size(); i++)
          {
            //Mesmo nome mas diferentes tipos de retorno
            if(!hashMethods.get(id).get(i).returnType.equals(method.returnType))
            {
                nt = (NodeToken)method.f1.f0.choice;
                throw new SemanticException("impossible to overload method '"+method.name+"' in class '"+name+"' with the return type '"+method.returnType+"'"+
                          "\n>>expected '"+hashMethods.get(id).get(i).returnType+"'",nt.beginLine, nt.beginColumn);
            }
            else
            {
                /*lista de parâmetros iguais, ou seja, tentando sobrescrever um método já existente na mesma classe, pretty bad :( */
                if(hashMethods.get(id).get(i).checkParams(method))
                    throw new SemanticException("impossible to overload method '"+method.name+"' in class '"+name+"'"+
                          "\n>>a method with the same name and parameters already exists in the same class",hashMethods.get(id).get(i).f2.beginLine, hashMethods.get(id).get(i).f2.beginColumn);
                    
            }

          }


       }

       if(hashMethods.get(id) == null)
       {
           hashMethods.put(id, new Vector<MethodDecl>());
       }
       hashMethods.get(id).add(method);

       /*Repetição do método para possuir assinatura única
        *Todos os métodos terão o seguinte formato: nome[parametros]
        */
       hashMethods.put(method.toString(), new Vector<MethodDecl>());
       hashMethods.get(method.toString()).add(method);
   }

   //variableBelongs
   //verifica se uma variavel pertence ao conjunto das variaveis da classe
   public boolean variableBelongs(String variavel) {
       if (this.hashVariables.containsKey(variavel)) return true;
       return false;
   }

   public IRType accept(ansem.visitor.IRVisitor v) throws SemanticException {
      return v.visit(this);
   }

   public void accept(ansem.visitor.Visitor v) throws SemanticException {
      v.visit(this);
   }
   public <R,A> R accept(ansem.visitor.GJVisitor<R,A> v, A argu) {
      return v.visit(this,argu);
   }
   public <R> R accept(ansem.visitor.GJNoArguVisitor<R> v) throws SemanticException {
      return v.visit(this);
   }
   public <A> void accept(ansem.visitor.GJVoidVisitor<A> v, A argu) {
      v.visit(this,argu);
   }
}

