/**
 *
 * @author Antonio Noca, Ricardo
 */

//
// Generated by JTB 1.3.2
//

package ansem.visitor;
import ansem.syntaxtree.*;
import java.util.*;


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class TypeCheckingVisitor<String> implements GJNoArguVisitor<String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public String visit(NodeList n) throws SemanticException {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeListOptional n) throws SemanticException {
      if ( n.present() ) {
         String _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public String visit(NodeOptional n) throws SemanticException {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public String visit(NodeSequence n) throws SemanticException {
      String _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public String visit(NodeToken n) throws SemanticException { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * <PRE>
    * f0 -> &lt;VIRGULA&gt;
    * f1 -> Type()
    * f2 -> &lt;ID&gt;
    * </PRE>
    */
   public String visit(FormalRest n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> ( Type() &lt;ID&gt; ( FormalRest() )* )?
    * </PRE>
    */
   public String visit(FormalList n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;PUBLIC&gt;
    * f1 -> Type()
    * f2 -> &lt;ID&gt;
    * f3 -> &lt;LPAR&gt;
    * f4 -> FormalList()
    * f5 -> &lt;RPAR&gt;
    * f6 -> &lt;LCHAVE&gt;
    * f7 -> ( VarDecl() )*
    * f8 -> ( Statement() )*
    * f9 -> &lt;RETURN&gt;
    * f10 -> Exp()
    * f11 -> &lt;PVIRGULA&gt;
    * f12 -> &lt;RCHAVE&gt;
    * </PRE>
    */
   public String visit(MethodDecl n) throws SemanticException {
      SemanticInfo.currentMethod = n;
      
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;INT&gt; &lt;LCOL&gt; &lt;RCOL&gt;
    *       | &lt;INT&gt;
    *       | &lt;BOOLEAN&gt;
    *       | &lt;ID&gt;
    * </PRE>
    */
   public String visit(Type n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> Type()
    * f1 -> &lt;ID&gt;
    * f2 -> &lt;PVIRGULA&gt;
    * </PRE>
    */
   public String visit(VarDecl n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;CLASS&gt; &lt;ID&gt; &lt;LCHAVE&gt; ( VarDecl() )* ( MethodDecl() )* &lt;RCHAVE&gt;
    *       | &lt;CLASS&gt; &lt;ID&gt; &lt;EXTENDS&gt; &lt;ID&gt; &lt;LCHAVE&gt; ( VarDecl() )* ( MethodDecl() )* &lt;RCHAVE&gt;
    * </PRE>
    */
   public String visit(ClassDecl n) throws SemanticException {
      SemanticInfo.currentClass = n;
      SemanticInfo.currentMethod = null;

      String _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;VIRGULA&gt;
    * f1 -> Exp()
    * </PRE>
    */
   public String visit(ExpRest n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> ( Exp() ( ExpRest() )* )?
    * </PRE>
    */
   public String visit(ExpList n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> ExpSemLR()
    * f1 -> ExpComRR()
    * </PRE>
    */
   public String visit(Exp n) throws SemanticException {
      /*
       * - tem momentos que f1 eh null
       * - nem sempre precisa comparar f0 com f1.
       *   eh bom saber um jeito de como saber quando comparar.
       */
      String tipoF0=null;
      String tipoF1=null;

      if(n.f0 != null) {
          tipoF0 = n.f0.accept(this);
      }
      if(n.f1 != null) {
          tipoF1 = n.f1.accept(this);
      }
      
      
      return (String)"";
   }

   /**
    * <PRE>
    * f0 -> (
    *   0: &lt;BINOP&gt; Exp() ExpComRR()
    * | 1: &lt;LCOL&gt; Exp() &lt;RCOL&gt; ExpComRR()
    * | 2: &lt;DOT&gt; &lt;LENGTH&gt; ExpComRR()
    * | 3: &lt;DOT&gt; &lt;ID&gt; &lt;LPAR&gt; ExpList() &lt;RPAR&gt; ExpComRR() )?
    * </PRE>
    */
   public String visit(ExpComRR n) throws SemanticException {
       String _ret=null;
       int which=-1;
       NodeChoice nc = null;
       NodeSequence ns = null;

       //temos um nodeChoice valido ?
       //TODO teria que colocar antes a condicao "n.f0.node != null" ??
       if (n.f0.node != null) {
           if (n.f0.present()) {
               nc = (NodeChoice)n.f0.node;
               which = nc.which; //guarda a producao usada

               ns = (NodeSequence)nc.choice;

               switch (which) {
                   case 0: //Exp op Exp
                       /*
                        * tipo1 = accept(E1)
                        * tipo2 = accept(E2)
                        * se tipo1 == tipo2
                        *   retorna tipo1
                        */
                       /*
                        * 0 = op
                        * 1 = exp
                        * 2 = exp
                        */
                       String tipo1 = (String)ns.elementAt(1).accept(this);
                       String tipo2 = (String)ns.elementAt(2).accept(this);
                       if (tipo1.equals(tipo2)) {
                           return tipo1;
                       }
                       else {
                           //TODO: lancar erro !
                   //        System.out.println("erro em exp op exp, tipos diferentes");
                       }
                       break;
                   case 1: //Exp[Exp] (eg: calcular(a,b)[0]; sendo que calcular retorna array de int)
                       /*
                        * e1[e2]
                        * ------
                        * compara e2 com int
                        * compara e1 com "int array"
                        * retorna "int array"
                        */
                       /*
                        * 0 = [
                        * 1 = e2
                        * 2 = ]
                        * 3 = e1
                        */
                        String tipoDeE2 = (String)ns.elementAt(1).accept(this);
                       if (tipoDeE2.equals((String)"int")) {
                           String tipoDeE1 = (String)ns.elementAt(3).accept(this);
                           if (tipoDeE1.equals((String)"int array")) {
                               return tipoDeE1; //'int array'
                           }
                           else {
                               //TODO: Lancar erro em exp1[exp2]
                 //              System.out.println("erro 1 !");
                           }

                       }
                       else {
                           //TODO: Lancar erro em exp1[exp2]
                 //          System.out.println("erro 2 !");
                       }
                       break;
                   case 2: //Exp.length
                       /*
                        * compara Exp com "int array"
                        * retorna int
                        */
                       /*
                        * 0 = .
                        * 1 = length
                        * 2 = exp
                        */
                        String tipoDeExp = (String)ns.elementAt(2).accept(this);
                        if (tipoDeExp.equals((String)"int array") ) {
                            return (String)"int";
                        }
                       break;
                   case 3: //Exp.id(ExpList)
                       /*
                        * procura onde esta' definido Exp
                        */
                       /*
                        * 0 = .
                        * 1 = id
                        * 2 = (
                        * 3 = explist
                        * 4 = )
                        * 5 = exp
                        */

                       break;
                   case -1:
                       //TODO: mensagem de erro ?
                     //  System.out.println("which = -1, mensagem de erro ? ");
                       break;
               } //SWITCH

           } //IF
       } //IF

       n.f0.accept(this);
       return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;INTEGER_LITERAL&gt;
    *       | &lt;TRUE&gt;
    *       | &lt;FALSE&gt;
    *       | &lt;ID&gt;
    *       | &lt;THIS&gt;
    *       | &lt;NEW&gt; &lt;INT&gt; &lt;LCOL&gt; Exp() &lt;RCOL&gt;
    *       | &lt;NEW&gt; &lt;ID&gt; &lt;LPAR&gt; &lt;RPAR&gt;
    *       | &lt;UNOP&gt; Exp()
    *       | &lt;LPAR&gt; Exp() &lt;RPAR&gt;
    * </PRE>
    */
   public String visit(ExpSemLR n) throws SemanticException {
      String _ret=null;
      int which=-1;

      //=== VERIFICACAO DO N ===
      //n.f0 sempre eh um node choice
      which = n.f0.which;
      NodeSequence ns=null;

      //nao entendi..
      if (n.f0.which == 6) { //n.f0 sempre eh um node choice
          ns = (NodeSequence)n.f0.choice;
      }
      //=== FIM VERIFICACAO DO N ===


      MethodDecl metodoAtual = SemanticInfo.currentMethod;
      ClassDecl classeAtual = SemanticInfo.currentClass;
      switch(which) {
          case (0): //INTEGER_LITERAL              
              _ret=(String)"int";
              return _ret;
          case (1): //TRUE
              _ret=(String)"boolean";
              return _ret;
          case (2): //FALSE
              _ret=(String)"boolean";
              return _ret;
          case (3): //ID
              /*
               * se id pertence vars_metodo_atual
               *    retorna tipo
               * senao se id pertence params_metodo_atual
               *    retorna tipo
               * senao se id pertence vars_classe_atual
               *    retorna tipo
               * senao
               *    lanca erro !
               */
              if (metodoAtual.variableBelongsToLocalVariables(n.f0.choice.toString())) {
                  _ret = (String) metodoAtual.getVariableType(n.f0.choice.toString(), "local");
                  return _ret;
              }
              else if (metodoAtual.variableBelongsToParamVariables(n.f0.choice.toString())) {
                  _ret = (String) metodoAtual.getVariableType(n.f0.choice.toString(), "local");
                  return _ret;
              }
              else if (classeAtual.variableBelongs(n.f0.choice.toString())) {
                  _ret = (String) classeAtual.getVariableType(n.f0.choice.toString());
                  return _ret;
              }
              else {
                  //TODO: lancar erro ExpSemLR, ID.
                  //mensagem, linha, coluna
                  //System.out.println("ExpSemLR, n.f0: "+n.f0);
              }
          case (4): //THIS
              _ret=(String)classeAtual.name;
              return _ret;
          case (5): //NEW INT
              _ret=(String)"int array";
              return _ret;
          case (6): //NEW ID
              _ret=(String)classeAtual.name;
              return _ret;
          case (7): //UNOP
              _ret=(String)"boolean";
              return _ret;
          case (8): //LPAR
              //TODO
              //System.out.println("ExpSemLR, n.f0.which: "+n.f0.which);
              //System.out.println("ExpSemLR, n.f0.choice: "+n.f0.choice);
      }

      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;LCHAVE&gt; ( Statement() )* &lt;RCHAVE&gt;
    *       | &lt;IF&gt; &lt;LPAR&gt; Exp() &lt;RPAR&gt; Statement() &lt;ELSE&gt; Statement()
    *       | &lt;WHILE&gt; &lt;LPAR&gt; Exp() &lt;RPAR&gt; Statement()
    *       | &lt;SYSTEM&gt; &lt;DOT&gt; &lt;OUT&gt; &lt;DOT&gt; &lt;PStringINTLN&gt; &lt;LPAR&gt; Exp() &lt;RPAR&gt; &lt;PVIRGULA&gt;
    *       | &lt;ID&gt; &lt;ASSIGN&gt; Exp() &lt;PVIRGULA&gt;
    *       | &lt;ID&gt; &lt;LCOL&gt; Exp() &lt;RCOL&gt; &lt;ASSIGN&gt; Exp() &lt;PVIRGULA&gt;
    * </PRE>
    */
   public String visit(Statement n) throws SemanticException {
      String _ret=null;
      int which=-1;     //regra utilizada em n

      MethodDecl metodoAtual = SemanticInfo.currentMethod;
      ClassDecl classeAtual = SemanticInfo.currentClass;
      
      //=== VERIFICACAO DO N ===
      NodeSequence ns=null;
      if (n.f0 != null) { //n.f0 sempre eh um node choice
          if ((NodeSequence)n.f0.choice != null) { //choice eh sempre nodesequence
            ns = (NodeSequence)n.f0.choice;
            which = n.f0.which;
          }
          else {
              //TODO: erro ?
              //System.out.println("erro ?! statement.n.f0.choice eh null");
              System.exit(0);
          }
      }
      else {
          //TODO: erro !? statement.n.f0 eh null
          //System.out.println("erro !? statement.n.f0 eh null");
          //System.exit(0);
      }
      //=== FIM VERIFICACAO DO N ===


      //=== QUAL REGRA UTILIZADA ===      
      if (which == 4) { // Statement -> id = Exp
          /* RACIOCINIO
           * recupera id
           * se id pertence vars_metodo_atual
           *    retorna tipo
           * senao se id pertence params_metodo_atual
           *    retorna tipo
           * senao se id pertence vars_classe_atual
           *    retorna tipo
           * senao
           *    lanca erro !
           */
          /*
           * se estamos no which = 4:
           * ns.elementAt(0) eh a variavel da esquerda
           * ns.elementAt(1) eh o "="
           * ns.elementAt(2) eh um no' Exp
          */
          String variavelDaEsquerdaDaAtribuicao=(String)ns.elementAt(0).toString();
          String tipoDaEsquerdaDaAtribuicao=(String)"";
          String tipoDaExpressao=(String)"";


          if (metodoAtual.variableBelongsToLocalVariables(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) metodoAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString(), "local");
          }
          else if (metodoAtual.variableBelongsToParamVariables(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) metodoAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString(), "local");
          } 
          else if (classeAtual.variableBelongs(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) classeAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString());
          }
          else {
              //TODO: lancar erro statement, ID esquerda.
              //mensagem, linha, coluna
              System.out.println("erro no statement, id da esquerda " +
                      "da atribuicao nao definido ");
          }

          //ns.elementAt(2) eh um no' Exp
          //tipo da expressao
          tipoDaExpressao = (String)ns.elementAt(2).accept(this);
          
          
          if (!tipoDaEsquerdaDaAtribuicao.equals(tipoDaExpressao)) {
              //TODO: lanca excecao ! deu pau na atribuicao
          }
          else { //mostra mensagem feliz
              System.out.println("tudo funcionando no stament regra 4! \\o/");
          }
          
      }

      // Statement -> id [Exp] = Exp
      if (which == 5) {
          /* RACIOCINIO
           * recupera id
           * se id pertence vars_metodo_atual
           *    retorna tipo
           * senao se id pertence params_metodo_atual
           *    retorna tipo
           * senao se id pertence vars_classe_atual
           *    retorna tipo
           * senao
           *    lanca erro !
           */
          
          /*
           * estando na regra 5
           * ns.elementAt(0) id
           * ns.elementAt(1) [
           * ns.elementAt(2) Exp
           * ns.elementAt(3) ]
           * ns.elementAt(4) =
           * ns.elementAt(5) Exp
           * ns.elementAt(6) ;
          */
          
          String variavelDaEsquerdaDaAtribuicao=(String)ns.elementAt(0).toString();
          String tipoDaEsquerdaDaAtribuicao=(String)"";
          String tipoDaExpressaoDaEsquerda=(String)"";
          String tipoDaExpressaoDaDireita=(String)"";
          

          if (metodoAtual.variableBelongsToLocalVariables(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) metodoAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString(), "local");
          }
          else if (metodoAtual.variableBelongsToParamVariables(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) metodoAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString(), "local");
          }
          else if (classeAtual.variableBelongs(variavelDaEsquerdaDaAtribuicao.toString())) {
              tipoDaEsquerdaDaAtribuicao = (String) classeAtual.getVariableType(variavelDaEsquerdaDaAtribuicao.toString());
          }
          else {
              //TODO: lancar erro statement, ID esquerda.
              //mensagem, linha, coluna
              System.out.println("erro no statement, id da esquerda " +
                      "da atribuicao do array nao definido ");
          }

          //ns.elementAt(2) eh um no' Exp
          //tipo da expressao (esquerda ou direita)
          tipoDaExpressaoDaEsquerda = (String)ns.elementAt(2).accept(this);
          tipoDaExpressaoDaDireita = (String)ns.elementAt(5).accept(this);
          
          // ID tem que ser int array
          if (!tipoDaEsquerdaDaAtribuicao.equals("int array")) {
              //TODO: lanca excecao ! O tipo da variavel id nao e' array de int
               System.out.println("erro 1 'O tipo da variavel id nao e' array de int' regra 5!");
          }
          // tipo do EXP da quantidade de elementos do vetor = int
          else if (!tipoDaExpressaoDaEsquerda.equals("int")) {
              //TODO: lanca excecao ! O tipo do EXP da quantidade de elementos do array deve ser int
               System.out.println("erro 2 'O tipo do EXP da quantidade de elementos do array deve ser int' regra 5!");
          }
          // tipo do EXP da atribuicao = int
          else if (!tipoDaExpressaoDaDireita.equals("int")) {
              //TODO: lanca excecao ! O tipo do EXP da atribuicao para o array deve ser int
               System.out.println("erroo 3 no stament regra 5! \\o/");
          }
          else { //mostra mensagem feliz
              System.out.println("tudo funcionando no stament regra 5! \\o/");
          }

      }

      n.f0.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> &lt;CLASS&gt;
    * f1 -> &lt;ID&gt;
    * f2 -> &lt;LCHAVE&gt;
    * f3 -> &lt;PUBLIC&gt;
    * f4 -> &lt;STATIC&gt;
    * f5 -> &lt;VOID&gt;
    * f6 -> &lt;MAIN&gt;
    * f7 -> &lt;LPAR&gt;
    * f8 -> &lt;STStringING&gt;
    * f9 -> &lt;LCOL&gt;
    * f10 -> &lt;RCOL&gt;
    * f11 -> &lt;ID&gt;
    * f12 -> &lt;RPAR&gt;
    * f13 -> &lt;LCHAVE&gt;
    * f14 -> Statement()
    * f15 -> &lt;RCHAVE&gt;
    * f16 -> &lt;RCHAVE&gt;
    * </PRE>
    */
   public String visit(MainClass n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      n.f13.accept(this);
      n.f14.accept(this);
      n.f15.accept(this);
      n.f16.accept(this);
      return _ret;
   }

   /**
    * <PRE>
    * f0 -> MainClass()
    * f1 -> ( ClassDecl() )*
    * f2 -> &lt;EOF&gt;
    * </PRE>
    */
   public String visit(Start n) throws SemanticException {
      String _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

}
